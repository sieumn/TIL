# [OS] Chap 1. Introduction

> Operating System Concepts 10th Edition (a.k.a. 공룡책) - Chap 1을 읽고 정리합니다.

## Operating System

운영체제(OS, Operating System)는 컴퓨터의 하드웨어를 관리하는 소프트웨어로, 하드웨어와 사용자 사이에서 매개체 역할을 한다.

## 1.1 What OS Do

컴퓨터 시스템은 크게 하드웨어, 애플리케이션 프로그램, 유저, 그리고 운영체제의 네 가지 요소로 나눌 수 있다.

![](images/2021-10-16-08-13-16.png)

하드웨어는 CPU, memory, I/O device 등 시스템에 기본적인 컴퓨팅 자원을 제공한다. 애플리케이션 프로그램은 사용자가 컴퓨팅 문제를 해결하는 방식을 정의한다. 이 때, 하드웨어와 애플리케이션 프로그램 사이에서 하드웨어를 관리하고 사용자들이 애플리케이션 프로그램을 사용할 수 있도록 환경을 제공하는 것이 운영체제의 역할이다.

운영체제는 다시 사용자 관점과 시스템 관점으로 나누어 생각해볼 수 있다.

### 1.1.1 User View

사용자 관점에서 운영체제의 목표는 사용자가 수행하는 일의 퍼포먼스를 최대화하는 것이다. 이를 위해 운영체제는 퍼포먼스와 보안에 좀 더 초점을 맞추도록 디자인되어야 할 것이다.

### 1.1.2 System View

시스템 관점에서 운영체제는 하드웨어와 프로그램을 더 긴밀하게 연결하는 목표를 갖는다. 이러한 맥락에서 운영체제는 자원 할당자의 역할을 한다. 운영체제는 컴퓨터 시스템을 효율적이고 공평하게 운영하기 위해, 각 프로그램과 사용자에게 어떻게 자원을 할당할 지를 결정한다. 또한 운영체제는 제어 프로그램의 역할을 한다. 운영체제는 프로그램이 시스템에 부적절하게 접근하는 것을 방지하고 프로그램에 에러가 발생하는 것을 방지한다.

### 1.1.3 Defining Operating System

하드웨어는 그 자체로는 다루기 쉽지 않기 때문에, 사용자들을 위한 애플리케이션 프로그램이 개발되었다. 이 때, 애플리케이션 프로그램은 I/O 디바이스 관리, 자원 할당 등의 기능을 하드웨어에 요구하게 되는데, 이렇게 애플리케이션 프로그램이 요구하는 공통적인 기능을 한 데 모아 소프트웨어로 구현한 것이 바로 운영체제이다.

운영체제는 하드웨어 위에서 항상 동작하는 단 하나의 프로그램이며, 이것은 커널(kernel)이라고도 불린다. 커널은 운영체제의 핵심이며, 일반적으로 커널은 운영체제와 동일시 되는 경우가 많다.

## 1.2 Computer-System Organization

일반적인 컴퓨터 시스템은 하나 이상의 CPU, 여러 개의 장치 컨트롤러(device controller), 그리고 장치 컨트롤러와 공유 메모리를 연결하는 공통 버스(common bus)로 구성된다. 장치 컨트롤러에는 한 개 이상의 장치들이 연결되어 있다.

일반적으로 운영체제는 각 장치 컨트롤러마다 장치 드라이버를 갖는다. 장치 드라이버는 장치 컨트롤러를 이해하고, 운영체제에 장치에 대한 인터페이스를 제공한다.

![](images/2021-10-16-08-50-16.png)

### 1.2.1 Interrupts

#### An example: a Program performing I/O

I/O 동작 과정을 살펴 보자. I/O 동작을 시작하기 위해, 장치 드라이버는 장치 컨트롤러로부터 적절한 레지스터를 로드한다. 장치 컨트롤러는 레지스터의 내용을 확인한 후에, 어떤 '키보드로부터 문자 입력 받기' 등 어떤 실행 동작을 취할지 결정한다. 장치 컨트롤러는 장치로부터 데이터를 입력 받아 로컬 버퍼(local buffer)에 먼저 저장하고, 데이터 입력이 끝나면 장치 드라이버에게 동작이 끝났음을 알린다. 장치 드라이버가 운영체제에 제어권을 넘겨주면, 운영체제는 로컬 버퍼의 데이터를 메모리 영역으로 이동시키고, 데이터가 저장된 메모리 위치 등을 반환할 것이다.

이 때, 장치 컨트롤러는 장치 드라이버에게 동작이 끝났다는 것을 어떻게 알릴 수 있을까? 이것은 인터럽트(interupt)에 의해 수행된다.

#### Interrupt Implementation

하드웨어는 시스템 버스를 통해 CPU에 신호를 전송함으로써 인터럽트를 발생시킨다. 인터럽트는 운영체제와 하드웨어가 소통하는 핵심적인 방법이다.

![](images/2021-10-16-09-35-04.png)

컴퓨터는 여러 작업을 병렬적으로 처리한다. CPU에 인터럽트가 발생하면, CPU는 수행하던 동작을 중단하고 즉시 메모리의 특정 위치로 이동한다. 이 위치는 인터럽트 벡터(interrupt vector)에 저장되어 있으며, 인터럽트 벡터에는 인터럽트를 처리할 수 있는 서비스 루틴의 시작 주소가 저장되어 있다. CPU는 해당 인터럽트를 처리하고, 다시 돌아와 기존에 하던 수행을 계속한다.

컨트롤러가 인터럽트 신호를 발생시키면, 인터럽트 신호들은 CPU의 인터럽트 요청 라인(interrupt request line)에 저장된다. CPU는 인터럽트 요청 라인에 접근하여 인터럽트 인덱스 번호를 읽고, 적절한 인터럽트 벡터로 인터럽트를 보낸다. 인터럽트 핸들러(interrupt handler)는 적절한 서비스 루틴을 수행함으로써 인터럽트를 종결시킨다.

![](images/2021-10-16-10-37-01.png)

#### Maskable / Non-maskable Interrupt

대부분의 CPU는 두 개의 인터럽트 요청 라인을 갖는다. 첫 번재는 마스크가 불가능한 인터럽트(NMI, non-maskable interrupt)로, 무시될 수 없는 매우 중요한 인터럽트다. 복구할 수 없는 메모리 오류 등과 같은 심각한 이벤트를 위한 것이다. 두 번째로는 마스크 가능한 인터럽트(maskable interrupt)이며, 이 경우 CPU가 방해할 수 없는 중요한 동작을 수행하고 있을 경우 인터럽트가 처리되지 않을 수 있다.

#### Interrupt Chaining

CPU는 빠른 동작을 위해 인터럽트 벡터에 서비스 루틴을 저장하도 있지만, 실제로 컴퓨터는 인터럽트 벡터 사이즈보다 더 많은 장치를 갖는다. 이 때 인터럽트 벡터에 특정 핸들러 리스트의 head를 저장하는 인터럽트 연결(interrupt channing) 방식을 사용한다. 예를 들어 Intel 프로세서의 인터럽트 벡터는 다음과 같이 설계되어 있다.

![](images/2021-10-16-10-53-50.png)

#### Interrupt Priority Level

각 인터럽트는 우선순위 레벨을 갖는다. 이 레벨은 CPU가 작업과 인터럽트의 우선순위를 비교하여 수행 순서를 결정하기 위해 필요하다.

### 1.2.2 Storage Structure

메모리 구조는 크게 주기억장치(primary storage), 보조 기억장치(secondary storage), 제3차 기억장치(tertiary storage)로 구분된다. 각 메모리 영역은 용량, 속도, 휘발 여부에 따라 구분되며, 용량과 속도는 트레이드 오프 관계에 있다.

![](images/2021-10-17-09-17-45.png)

CPU는 명령을 메모리(main memory, RAM)에서 불러오며, 따라서 모든 프로그램은 실행되기 위해 메인 메모리에 먼저 로드되어야 한다. CPU가 명령을 실행시킬 때는 메인 메모리의 데이터를 레지스터(register)로 로드한다. 실행이 완료된 후에는 레지스터의 데이터가 다시 메인 메모리로 저장된다. 레지스터, 캐시, 메인 메모리를 합쳐 주기억장치(primary storage)라고 부르며, 주기억장치는 DRAM 등 동작이 빠른 휘발성 메모리로 구성된다.

이상적으로는 메인 메모리에 모든 것을 저장하는 것이 좋지만, 메인 메모리는 모든 프로그램과 데이터를 저장하기에는 용량이 매우 작고, 휘발성 메모리기 때문에 컴퓨터 전원이 종료되면 모든 데이터가 지워진다는 한계가 있다.

따라서, 컴퓨터 시스템은 더 많은 데이터를 영구적으로 저장할 수 있는 보조 기억장치(secondary storage)를 제공한다. 보조 기억장치에는 HDD(hard disk drivers)나 비휘발성 메모리(NVM, nonvolatile memory) 등이 있다. 대부분의 프로그램들은 메모리에 로드되기 전까지 보조 기억장치에 저장된다. 보조 기억장치는 데이터를 영구적으로 저장할 수 있는 대신 메인 메모리보다 훨씬 속도가 느리다.

그 외, 광학 디스크나 자기 테이프 등의 메모리는 제3차 메모리(tertiary storage)라고 부른다. 제3차 메모리는 더 큰 용량을 가지만, 보조 기억장치보다도 더 느리다.

### 1.2.3 I/O Structure

적은 데이터를 다룰 경우에는 앞서 본 것처럼 인터럽트를 발생시키면서 데이터를 메모리에 저장하는 것이 가능하겠지만, 매우 많은 데이터(bulk data)를 다룬다면 큰 CPU에 오버헤드를 발생시킬 것이다. 많은 데이터의 전송이 완료될 때까지 CPU가 대기해야 하는 상황이 벌어질 수 있다. 이 문제를 해결하기 위해 direct memory access(DMA)가 고안되었다.

![](images/2021-10-17-09-35-01.png)

DMA는 장치와 메모리를 직접 연결하는 방식으로, 버스가 지원하는 기능이다. DMA 동작에서 장치 컨트롤러는 CPU에게 모든 데이터 바이트(byte)마다 인터럽트를 보내는 대신, 전체 데이터 블록(block)를 메모리에 직접 전송한다. CPU를 거치지 않고 메모리에 직접 접근하는 것이 핵심이다. 블록 데이터 전체를 메모리에 전송한 후, 블록 당 한 번의 인터럽트만 발생시켜 장치 드라이버에게 데이터 전송이 완료되었음을 알린다. CPU가 해야할 일을 DMA 동작이 대신 해줌으로써 CPU의 효율을 늘릴 수 있다.

## 1.3 Computer-System Architecture

아래 포스트에 정리가 잘 되어 있어 참고했다.
- https://parksb.github.io/article/5.html

### 1.3.1 Single-Processor Systems

과거 대부분의 컴퓨터는 싱글 프로세서를 사용했다. 싱글 프로세서 컴퓨터는 하나의 메인 CPU으로만 구성되는데, 장치에 따라 특별한 목적을 가진 프로세서가 들어갔다. 예를 들면, 디스크 프로세서는 디스크 연산만 수행하고, 키보드 프로세서는 키보드 연산만 수행한다.

### 1.3.2 Multiprocessor Systems

멀티 프로세서 컴퓨터는 두 개 이상의 프로세서를 사용하는 컴퓨터로, 각 프로세서들은 컴퓨터 버스와 클락, 메모리, 주변 장치 등을 공유할 수 있다. 멀티 프로세서의 가장 큰 장점은 처리량의 증가로, 더 적은 시간에 더 많은 양의 일을 처리할 수 있다.

멀티 프로세서 시스템은 대칭 멀티 프로세싱(symmetric multiprocessing)과 비대칭 멀티 프로세싱(asymmetric multiprocessing)으로 나뉜다. 비대칭 멀티 프로세싱은 메인 프로세서가 시스템을 제어하고, 다른 프로세서는 메인 프로세서의 지시를 받아 동작한다. 부하 분산(load balancing)을 효율적으로 할 수 있지만, 메인 프로세서가 작동을 멈추면 하위 프로세서들도 멈추게 된다. 반면 멀티 프로세싱에서 모든 프로세서들은 하나의 메모리를 공유하고 동일한 작업을 병렬적으로 수행한다. 만약 프로세서에 이상이 생겨 작동을 멈춰야 한다면 자신이 수행하던 작업을 다른 프로세서들에게 나눠주고 자신만 재부팅한다. 비대칭 멀티프로세싱 시스템의 단점을 보완할 수 있는 아키텍처이기 때문에 대부분의 컴퓨터 시스템은 대칭 멀티프로세싱을 사용한다.

![](images/2021-10-17-10-07-57.png)

멀티 프로세서 시스템은 멀티 코어 시스템으로 진화했다. 각 프로세서에 여러 개의 코어가 있는 구조로, 프로세서 칩간의 거리보다 칩 내에 있는 코어간의 거리가 더 가깝기 때문에, 멀티 프로세서 씨스템보다 더 빠르고 효율적인 동작을 할 수 있게 되었다.

![](images/2021-10-17-10-13-26.png)

### 1.3.3 Clustered Systems

## Reference

- Operating system controls 10th edition
- https://parksb.github.io/article/5.html


